{{- if and .Values.minio.deploy .Values.sampleData.generate }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "alert-recommender-pipeline.fullname" . }}-upload-data
  labels:
    {{- include "alert-recommender-pipeline.labels" . | nindent 4 }}
spec:
  backoffLimit: 3
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      labels:
        {{- include "alert-recommender-pipeline.selectorLabels" . | nindent 8 }}
        job: upload-data
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ include "alert-recommender-pipeline.serviceAccountName" . }}
      containers:
        - name: upload-data
          image: {{ .Values.image.repository }}:{{ .Values.image.tag | default "latest" }}
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          env:
            - name: MINIO_ACCESS_KEY
              valueFrom:
                secretKeyRef:
                  name: {{ include "alert-recommender-pipeline.fullname" . }}-minio
                  key: access-key
            - name: MINIO_SECRET_KEY
              valueFrom:
                secretKeyRef:
                  name: {{ include "alert-recommender-pipeline.fullname" . }}-minio
                  key: secret-key
            - name: MINIO_ENDPOINT
              value: "http://minio-service:9000"
            - name: BUCKET_NAME
              value: {{ .Values.minio.bucketName | quote }}
            - name: DATA_VERSION
              value: {{ .Values.pipeline.dataVersion | quote }}
            - name: NUM_USERS
              value: {{ .Values.sampleData.numUsers | default 50 | quote }}
            - name: NUM_TRANSACTIONS
              value: {{ .Values.sampleData.numTransactions | default 5000 | quote }}
          command:
            - python
            - -c
            - |
              import os
              import time
              import pandas as pd
              import numpy as np
              from datetime import datetime, timedelta
              import boto3
              from botocore.client import Config
              import io
              import random
              import uuid
              
              # Configuration
              minio_endpoint = os.environ['MINIO_ENDPOINT']
              access_key = os.environ['MINIO_ACCESS_KEY']
              secret_key = os.environ['MINIO_SECRET_KEY']
              bucket_name = os.environ['BUCKET_NAME']
              data_version = os.environ['DATA_VERSION']
              num_users = int(os.environ.get('NUM_USERS', 50))
              num_transactions = int(os.environ.get('NUM_TRANSACTIONS', 5000))
              
              print(f"Configuration:")
              print(f"  MinIO Endpoint: {minio_endpoint}")
              print(f"  Bucket: {bucket_name}")
              print(f"  Data Version: {data_version}")
              print(f"  Generating {num_users} users and {num_transactions} transactions")
              
              # Initialize S3 client
              s3_client = boto3.client(
                  's3',
                  endpoint_url=minio_endpoint,
                  aws_access_key_id=access_key,
                  aws_secret_access_key=secret_key,
                  config=Config(signature_version='s3v4'),
                  region_name='us-east-1'
              )
              
              # Wait for MinIO to be ready
              print("\nWaiting for MinIO to be ready...")
              for i in range(60):
                  try:
                      s3_client.list_buckets()
                      print("MinIO is ready!")
                      break
                  except Exception as e:
                      print(f"Waiting for MinIO... ({i+1}/60)")
                      time.sleep(5)
              else:
                  raise RuntimeError("MinIO did not become ready in time")
              
              # Create bucket if it doesn't exist
              try:
                  s3_client.head_bucket(Bucket=bucket_name)
                  print(f"Bucket '{bucket_name}' already exists")
              except:
                  print(f"Creating bucket '{bucket_name}'...")
                  s3_client.create_bucket(Bucket=bucket_name)
              
              # Generate sample users
              print("\nGenerating sample users...")
              first_names = ['John', 'Jane', 'Michael', 'Emily', 'David', 'Sarah', 'Robert', 'Jennifer', 
                            'William', 'Lisa', 'James', 'Amanda', 'Thomas', 'Jessica', 'Daniel']
              last_names = ['Smith', 'Johnson', 'Williams', 'Brown', 'Jones', 'Garcia', 'Miller', 
                           'Davis', 'Rodriguez', 'Martinez', 'Hernandez', 'Lopez', 'Gonzalez', 'Wilson']
              states = ['CA', 'TX', 'FL', 'NY', 'IL', 'PA', 'OH', 'GA', 'NC', 'MI']
              
              users = []
              for i in range(num_users):
                  user_id = f'u-{str(i+1).zfill(3)}'
                  first_name = random.choice(first_names)
                  last_name = random.choice(last_names)
                  email = f"{first_name.lower()}.{last_name.lower()}{i}@example.com"
                  users.append({
                      'id': user_id,
                      'email': email,
                      'keycloak_id': str(uuid.uuid4()),
                      'first_name': first_name,
                      'last_name': last_name,
                      'phone_number': f'555-{str(random.randint(1000, 9999))}',
                      'created_at': '2025-01-01T00:00:00',
                      'updated_at': datetime.now().isoformat(),
                      'is_active': True,
                      'address_street': f'{random.randint(100, 9999)} Main St',
                      'address_city': random.choice(['Springfield', 'Riverside', 'Georgetown', 'Franklin']),
                      'address_state': random.choice(states),
                      'address_zipcode': str(random.randint(10000, 99999)),
                      'address_country': 'US',
                      'credit_limit': random.choice([5000, 7000, 10000, 12000, 15000]),
                      'credit_balance': round(random.uniform(0, 10000), 2)
                  })
              
              users_df = pd.DataFrame(users)
              print(f"Generated {len(users_df)} users")
              
              # Generate sample transactions
              print("\nGenerating sample transactions...")
              categories = ['Grocery', 'Gas & Transport', 'Shopping', 'Entertainment', 
                           'Restaurant', 'Health & Fitness', 'Home', 'Personal Care', 'Travel']
              merchants = {
                  'Grocery': ['Whole Foods', 'Trader Joes', 'Safeway', 'Costco', 'Kroger'],
                  'Gas & Transport': ['Shell', 'Chevron', 'BP', 'Uber', 'Lyft'],
                  'Shopping': ['Amazon', 'Target', 'Walmart', 'Best Buy', 'Macys'],
                  'Entertainment': ['Netflix', 'Spotify', 'AMC Theaters', 'Steam', 'Apple Music'],
                  'Restaurant': ['Chipotle', 'Starbucks', 'McDonalds', 'Dominos', 'Panera'],
                  'Health & Fitness': ['CVS', 'Walgreens', 'Planet Fitness', 'GNC', 'Vitamins'],
                  'Home': ['Home Depot', 'Lowes', 'IKEA', 'Bed Bath', 'Wayfair'],
                  'Personal Care': ['Sephora', 'Ulta', 'Great Clips', 'Massage Envy', 'Spa'],
                  'Travel': ['Delta', 'United', 'Marriott', 'Hilton', 'Airbnb']
              }
              
              transactions = []
              start_date = datetime(2025, 1, 1)
              
              for i in range(num_transactions):
                  user = random.choice(users)
                  category = random.choice(categories)
                  merchant = random.choice(merchants[category])
                  
                  # Generate realistic amounts based on category
                  if category == 'Grocery':
                      amount = round(random.uniform(20, 200), 2)
                  elif category == 'Gas & Transport':
                      amount = round(random.uniform(20, 80), 2)
                  elif category == 'Entertainment':
                      amount = round(random.uniform(10, 100), 2)
                  elif category == 'Restaurant':
                      amount = round(random.uniform(10, 80), 2)
                  elif category == 'Travel':
                      amount = round(random.uniform(100, 1000), 2)
                  else:
                      amount = round(random.uniform(10, 200), 2)
                  
                  trans_date = start_date + timedelta(
                      days=random.randint(0, 180),
                      hours=random.randint(6, 22),
                      minutes=random.randint(0, 59)
                  )
                  
                  transactions.append({
                      'id': str(uuid.uuid4()),
                      'user_id': user['id'],
                      'credit_card_num': f'{random.randint(4000,4999)}-{random.randint(1000,9999)}-{random.randint(1000,9999)}-{random.randint(1000,9999)}',
                      'amount': amount,
                      'currency': 'USD',
                      'description': f'Purchase at {merchant}',
                      'merchant_name': merchant,
                      'merchant_category': category,
                      'transaction_date': trans_date.isoformat(),
                      'transaction_type': 'PURCHASE',
                      'merchant_latitude': round(random.uniform(25, 48), 6),
                      'merchant_longitude': round(random.uniform(-122, -71), 6),
                      'merchant_zipcode': str(random.randint(10000, 99999)),
                      'merchant_city': user['address_city'],
                      'merchant_state': user['address_state'],
                      'merchant_country': 'US',
                      'status': 'APPROVED',
                      'authorization_code': str(random.randint(100000, 999999)),
                      'trans_num': uuid.uuid4().hex,
                      'created_at': trans_date.isoformat(),
                      'updated_at': trans_date.isoformat()
                  })
              
              transactions_df = pd.DataFrame(transactions)
              print(f"Generated {len(transactions_df)} transactions")
              
              # Upload to MinIO
              data_prefix = f'data/v{data_version}'
              
              # Upload users
              print(f"\nUploading users.csv to s3://{bucket_name}/{data_prefix}/users.csv")
              users_buffer = io.StringIO()
              users_df.to_csv(users_buffer, index=False)
              s3_client.put_object(
                  Bucket=bucket_name,
                  Key=f'{data_prefix}/users.csv',
                  Body=users_buffer.getvalue().encode('utf-8'),
                  ContentType='text/csv'
              )
              
              # Upload transactions
              print(f"Uploading transactions.csv to s3://{bucket_name}/{data_prefix}/transactions.csv")
              trans_buffer = io.StringIO()
              transactions_df.to_csv(trans_buffer, index=False)
              s3_client.put_object(
                  Bucket=bucket_name,
                  Key=f'{data_prefix}/transactions.csv',
                  Body=trans_buffer.getvalue().encode('utf-8'),
                  ContentType='text/csv'
              )
              
              # Verify uploads
              print("\nVerifying uploads...")
              response = s3_client.list_objects_v2(Bucket=bucket_name, Prefix=data_prefix)
              for obj in response.get('Contents', []):
                  print(f"  {obj['Key']} ({obj['Size']} bytes)")
              
              print("\nâœ“ Sample data upload complete!")
{{- end }}
